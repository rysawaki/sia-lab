<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>SIA v0.2 3D Lab</title>
<style>
  body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background: #000; color: #fff; }
  #info { position: absolute; top: 10px; width: 100%; text-align: center; pointer-events: none; z-index: 10; text-shadow: 0 0 5px #000; }
  h1 { margin: 0; font-size: 1.2rem; letter-spacing: 2px; color: #00ffcc; }
  #narrative {
    position: absolute; bottom: 30px; left: 30px;
    background: rgba(0, 0, 0, 0.8); border-left: 4px solid #00ffcc;
    padding: 15px; font-family: 'Consolas', monospace; font-size: 0.9rem;
    pointer-events: none; user-select: none;
    box-shadow: 0 0 20px rgba(0, 255, 204, 0.2);
    min-width: 300px;
  }
  .controls {
    position: absolute; top: 60px; right: 20px;
    background: rgba(20, 20, 20, 0.9); padding: 20px;
    border-radius: 8px; border: 1px solid #444;
    display: flex; flex-direction: column; gap: 15px;
    width: 220px;
  }
  .grp { display: flex; flex-direction: column; }
  label { font-size: 0.75rem; color: #aaa; margin-bottom: 5px; text-transform: uppercase; font-weight: bold; }
  input[type=range] { width: 100%; cursor: pointer; }
  button {
    background: #00ffcc; color: #000; border: none; padding: 10px;
    font-weight: bold; cursor: pointer; text-transform: uppercase;
    transition: 0.2s;
  }
  button:hover { background: #fff; box-shadow: 0 0 10px #fff; }
  .val { float: right; color: #00ffcc; }
  #loading { position: absolute; top: 50%; left: 50%; transform: translate(-50%,-50%); color: #00ffcc; font-size: 1.5rem; pointer-events: none;}
</style>
</head>
<body>

<div id="info">
  <h1>SIA v0.2 3D: POTENTIAL LANDSCAPE</h1>
  <p style="font-size:0.8rem; color:#aaa;">Left Drag: Move Objects | Right Drag: Rotate Camera</p>
</div>

<div id="loading">LOADING MODULES...</div>
<div id="narrative">SYSTEM: STANDBY</div>

<div class="controls">
  <div class="grp">
    <label>Memory Strength <span id="v_m" class="val">0.5</span></label>
    <input type="range" id="p_m" min="0" max="5.0" step="0.1" value="0.5">
  </div>
  <div class="grp">
    <label>Homeostasis (Bowl) <span id="v_a" class="val">0.5</span></label>
    <input type="range" id="p_a" min="0" max="1.0" step="0.05" value="0.5">
  </div>
  <div class="grp">
    <label>Neuroplasticity <span id="v_l" class="val">0.1</span></label>
    <input type="range" id="p_l" min="0" max="0.5" step="0.01" value="0.1">
  </div>
  <button id="btn_reset">RESET BRAIN</button>
</div>

<script type="module">
// Import Three.js directly from a reliable CDN
import * as THREE from 'https://cdn.skypack.dev/three@0.136.0';
import { OrbitControls } from 'https://cdn.skypack.dev/three@0.136.0/examples/jsm/controls/OrbitControls.js';

// --- SIA Logic Core ---
const _M={a:(a,b)=>a.map((v,i)=>v+b[i]),s:(a,b)=>a.map((v,i)=>v-b[i]),m:(v,s)=>v.map(x=>x*s),d:(a,b)=>a.reduce((s,v,i)=>s+v*b[i],0),n:(v)=>Math.sqrt(v.reduce((s,x)=>s+x*x,0)),z:(v)=>{let n=Math.sqrt(v.reduce((s,x)=>s+x*x,0));return n<1e-8?v.map(()=>0):v.map(x=>x/n)}};
const _C={t:0.05,g:[1.2,0.2],s:[0.2,-0.5],sg:0.35,sp:0.3,ah:0.5,eg:0.6,ep:0.4,ei:0.8,em:0.5,gm:0.1,kd:4.0,wg:1,wp:1.3,cw:0.7,ww:0.4,km:1,am:1.2,lr:0.1,dr:0.005,ml:1.5,e:1e-8};

class _T{
  constructor(){this.d=[[[0,0],[0,0]],[[0,0],[0,0]]]}
  gc(m){return m.map(v=>1/(1+Math.exp(-2*v)))}
  pd(h,c){
    let n=_M.n(h),i=n>_C.e?_M.m(h,1/n):h,o=[0,0];
    for(let k=0;k<2;k++){
      let t=this.d[k],pk=[t[0][0]*i[0]+t[0][1]*i[1],t[1][0]*i[0]+t[1][1]*i[1]];
      o=_M.a(o,_M.m(pk,c[k]))
    }
    let mg=_M.n(o);return mg>_C.e?_M.m(o,_C.ml*Math.tanh(mg)/mg):o
  }
  ip(hp,dr,c){
    let dn=_M.n(dr);if(dn<=_C.e)return;
    let uv=_M.m(dr,0.5/dn),hn=_M.n(hp),hi=hn>_C.e?_M.m(hp,1/hn):hp;
    for(let k=0;k<2;k++)if(c[k]>.01){
      let r=_C.lr*c[k];
      for(let i=0;i<2;i++)for(let j=0;j<2;j++)this.d[k][i][j]+=r*uv[i]*hi[j]
    }
    for(let k=0;k<2;k++)for(let i=0;i<2;i++)for(let j=0;j<2;j++)this.d[k][i][j]*=(1-_C.dr)
  }
}

class _A{
  constructor(){this.rst()}
  rst(){this.x=[0,0];this.y=[0,0];this.z=[0,0];this.w=new _T();this.tr=[]}
  up(){
    let dg=_M.s(this.x,_C.g),dp=_M.s(this.x,_C.s),Eg=Math.exp(-_M.d(dg,dg)/(2*_C.sg**2)),Ep=Math.exp(-_M.d(dp,dp)/(2*_C.sp**2));
    let gc=_M.m(this.x,_C.ah),ge=_M.m(_M.m(dg,-1/(_C.sg**2)),Eg),gv=_M.s(gc,_M.m(ge,_C.eg));
    let df=Eg-Ep,tg=[df,-df],dm=_M.m(_M.s(_M.m(tg,_C.am),_M.m(this.z,_C.km)),_C.t);
    this.z=_M.a(this.z,dm);
    let ctx=this.w.gc(this.z),pd=this.w.pd(this.x,ctx);
    let En=_C.wg*Eg-_C.wp*Ep+_C.ww*_C.cw,im=1/(1+Math.exp(-_C.kd*En));
    let bs=_M.s(_C.g,this.x),av=_M.s(this.x,_C.s),mb=Math.tanh(this.z[0]-this.z[1]);
    let dr=_M.a(_M.a(bs,_M.m(av,-0.4)),_M.m(bs,0.3*mb)),dh=_M.z(dr),it=_M.m(dh,im);
    this.y=_M.a(_M.m(this.y,1-_C.gm),_M.m(it,_C.gm));
    
    let v_pot=_M.m(gv,-_C.ep);
    let v_int=_M.m(this.y,_C.ei);
    let v_mem=_M.m(pd,_C.em);
    let vl=_M.a(v_pot,_M.a(v_int,v_mem)),dt=_M.m(vl,_C.t),xp=[...this.x];
    this.x=_M.a(this.x,dt);
    if(_M.n(dt)>_C.e)this.w.ip(xp,_M.m(dt,1/_C.t),ctx);
    this.tr.push([...this.x]);if(this.tr.length>300)this.tr.shift();
    return {i:v_int, m:v_mem, p:v_pot, eg:Eg, ep:Ep, im:im, mem_mag:_M.n(v_mem), pos:this.x}
  }
  // Potential Height Calc
  getPot(x, y) {
    let V_self = 0.5 * _C.ah * (x*x + y*y);
    let dG = Math.hypot(x-_C.g[0], y-_C.g[1]);
    let Eg = Math.exp(-(dG*dG)/(2*_C.sg**2));
    let V_goal = _C.eg * Eg;
    let dS = Math.hypot(x-_C.s[0], y-_C.s[1]);
    let Ep = Math.exp(-(dS*dS)/(2*_C.sp**2));
    let V_shock = 0.8 * Ep; 
    return (V_self - V_goal + V_shock);
  }
}
const ag = new _A();

// --- Three.js Setup ---
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x000000);
scene.fog = new THREE.FogExp2(0x000000, 0.1);

const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 100);
camera.position.set(0, -6, 5);
camera.up.set(0, 0, 1);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;

// Lights
const amLight = new THREE.AmbientLight(0x404040);
scene.add(amLight);
const pLight = new THREE.PointLight(0xffffff, 1, 100);
pLight.position.set(0, 0, 5);
scene.add(pLight);

// Objects
const sphereGeo = new THREE.SphereGeometry(0.12, 16, 16);

// Self
const selfMesh = new THREE.Mesh(sphereGeo, new THREE.MeshStandardMaterial({color:0xffffff, emissive:0x444444}));
scene.add(selfMesh);

// Goal
const goalMesh = new THREE.Mesh(sphereGeo, new THREE.MeshStandardMaterial({color:0x0088ff, emissive:0x0044aa}));
goalMesh.scale.set(1.5,1.5,1.5);
scene.add(goalMesh);
const goalLight = new THREE.PointLight(0x0088ff, 2, 4);
goalMesh.add(goalLight);

// Shock
const shockMesh = new THREE.Mesh(sphereGeo, new THREE.MeshStandardMaterial({color:0xff8800, emissive:0xaa4400}));
shockMesh.scale.set(1.5,1.5,1.5);
scene.add(shockMesh);
const shockLight = new THREE.PointLight(0xff8800, 2, 4);
shockMesh.add(shockLight);

// Arrows
const arrowInt = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 1, 0x00ff00);
scene.add(arrowInt);
const arrowMem = new THREE.ArrowHelper(new THREE.Vector3(1,0,0), new THREE.Vector3(0,0,0), 1, 0xaa00ff);
scene.add(arrowMem);

// Terrain (Dynamic Wireframe)
const segs = 40;
const planeGeo = new THREE.PlaneGeometry(8, 8, segs, segs);
const planeMat = new THREE.MeshBasicMaterial({color:0x00ffff, wireframe:true, transparent:true, opacity:0.15});
const terrain = new THREE.Mesh(planeGeo, planeMat);
scene.add(terrain);

// Trail
const trailMax = 200;
const trailPos = new Float32Array(trailMax*3);
const trailGeo = new THREE.BufferGeometry();
trailGeo.setAttribute('position', new THREE.BufferAttribute(trailPos, 3));
const trailLine = new THREE.Line(trailGeo, new THREE.LineBasicMaterial({color:0x888888, transparent:true, opacity:0.6}));
scene.add(trailLine);

// Interaction
const raycaster = new THREE.Raycaster();
const mouse = new THREE.Vector2();
const planeNormal = new THREE.Vector3(0,0,1);
const planeConstant = 0;
const interactPlane = new THREE.Plane(planeNormal, planeConstant);
let dragging = null;

function getIntersect(e){
  mouse.x = (e.clientX/window.innerWidth)*2-1;
  mouse.y = -(e.clientY/window.innerHeight)*2+1;
  raycaster.setFromCamera(mouse, camera);
  const target = new THREE.Vector3();
  raycaster.ray.intersectPlane(interactPlane, target);
  return target;
}
window.addEventListener('mousedown', e=>{
  if(e.button!==0)return;
  const p = getIntersect(e);
  if(!p)return;
  if(Math.hypot(p.x-_C.g[0], p.y-_C.g[1])<0.4) dragging='g';
  else if(Math.hypot(p.x-_C.s[0], p.y-_C.s[1])<0.4) dragging='s';
});
window.addEventListener('mousemove', e=>{
  if(!dragging)return;
  const p = getIntersect(e);
  if(dragging==='g') _C.g=[p.x, p.y];
  if(dragging==='s') _C.s=[p.x, p.y];
});
window.addEventListener('mouseup', ()=>dragging=null);
window.addEventListener('resize', ()=>{
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

// UI
document.getElementById('p_m').addEventListener('input',e=>{_C.em=parseFloat(e.target.value);document.getElementById('v_m').innerText=_C.em.toFixed(1)});
document.getElementById('p_a').addEventListener('input',e=>{_C.ah=parseFloat(e.target.value);document.getElementById('v_a').innerText=_C.ah.toFixed(2)});
document.getElementById('p_l').addEventListener('input',e=>{_C.lr=parseFloat(e.target.value);document.getElementById('v_l').innerText=_C.lr.toFixed(2)});
document.getElementById('btn_reset').addEventListener('click', ()=>ag.rst());

// Loop
const nBox = document.getElementById('narrative');
document.getElementById('loading').style.display='none';

function updateNarrative(data) {
  let txt="SYSTEM: STANDBY", col="#fff", bord="#333";
  if (data.ep>0.6){txt="⚠ DANGER: SHOCK PROXIMITY"; col="#ff4444"; bord="#ff0000";}
  else if (data.eg>0.8){txt="★ REWARD: GOAL REACHED"; col="#44aaff"; bord="#0088ff";}
  else if (data.ep>0.2&&data.im>0.5){txt="⚡ CONFLICT: WILL vs FEAR"; col="#ffaa00"; bord="#ff8800";}
  else if (data.mem_mag>0.8){txt="∞ FLOW: MEMORY DRIVEN"; col="#cc00ff"; bord="#aa00ff";}
  else if (data.im>0.1){txt="➤ INTENT: SEEKING"; col="#00ff00"; bord="#00ff00";}
  nBox.innerHTML = txt; nBox.style.color=col; nBox.style.borderLeftColor=bord;
}

function animate(){
  requestAnimationFrame(animate);
  const f = ag.up();
  
  // Terrain Z update
  const posAttr = terrain.geometry.attributes.position;
  for(let i=0; i<posAttr.count; i++){
    const x = posAttr.getX(i);
    const y = posAttr.getY(i);
    const z = ag.getPot(x,y);
    posAttr.setZ(i, z);
  }
  posAttr.needsUpdate = true;
  
  // Update Positions
  const zH = ag.getPot(f.pos[0], f.pos[1]);
  selfMesh.position.set(f.pos[0], f.pos[1], zH+0.12);
  
  const zG = ag.getPot(_C.g[0], _C.g[1]);
  goalMesh.position.set(_C.g[0], _C.g[1], zG);
  
  const zS = ag.getPot(_C.s[0], _C.s[1]);
  shockMesh.position.set(_C.s[0], _C.s[1], zS);
  
  // Arrows
  arrowInt.position.copy(selfMesh.position);
  arrowInt.setDirection(new THREE.Vector3(f.i[0],f.i[1],0).normalize());
  arrowInt.setLength(Math.hypot(f.i[0],f.i[1])*2.5);
  
  arrowMem.position.copy(selfMesh.position);
  arrowMem.setDirection(new THREE.Vector3(f.m[0],f.m[1],0).normalize());
  arrowMem.setLength(Math.hypot(f.m[0],f.m[1])*2.5);
  
  // Trail
  for(let i=trailMax-1;i>0;i--){
    trailPos[i*3]=trailPos[(i-1)*3];
    trailPos[i*3+1]=trailPos[(i-1)*3+1];
    trailPos[i*3+2]=trailPos[(i-1)*3+2];
  }
  trailPos[0]=f.pos[0]; trailPos[1]=f.pos[1]; trailPos[2]=zH+0.05;
  trailGeo.attributes.position.needsUpdate=true;
  
  updateNarrative(f);
  controls.update();
  renderer.render(scene, camera);
}
animate();
</script>
</body>
</html>
