<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>SIA Model - Trauma Edition</title>
    <style>
        body {
            background-color: #0d0d0d;
            color: #e0e0e0;
            font-family: 'Courier New', Courier, monospace;
            margin: 0;
            display: flex;
            flex-direction: column;
            /* iOS Safariのアドレスバー対策 (Dynamic Viewport Height) */
            height: 100vh;
            height: 100dvh; 
            overflow: hidden;
        }
        #header {
            padding: 10px 20px;
            background: #1a1a1a;
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
        }
        h1 { margin: 0; font-size: 1.1rem; color: #ff5252; }
        .subtitle { font-size: 0.7rem; color: #888; display: block;}
        .status-panel { text-align: right; }
        #action-display {
            font-size: 1.4rem;
            font-weight: bold;
            color: #66bb6a;
        }
        #canvas-container {
            position: relative;
            flex-grow: 1;
            width: 100%;
            background: #000;
            min-height: 0; /* Flexboxのはみ出し防止 */
        }
        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        .overlay-label {
            position: absolute;
            left: 10px;
            font-size: 0.8rem;
            opacity: 0.8;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }
        #controls {
            padding: 10px;
            background: #1a1a1a;
            border-top: 1px solid #333;
            display: grid;
            grid-template-columns: 1fr 1fr 2fr;
            gap: 8px;
            height: 80px; /* 固定高さ */
            flex-shrink: 0;
            padding-bottom: max(10px, env(safe-area-inset-bottom)); /* iPhone X以降の下部バー対策 */
        }
        button {
            border: none;
            border-radius: 6px;
            font-family: inherit;
            font-size: 1rem;
            font-weight: bold;
            color: white;
            cursor: pointer;
            transition: all 0.1s;
            -webkit-tap-highlight-color: transparent;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            line-height: 1.2;
        }
        button small { font-size: 0.7rem; opacity: 0.8; font-weight: normal; }
        button:active { transform: scale(0.96); filter: brightness(0.8); }
        
        .btn-v { background: linear-gradient(135deg, #b71c1c, #e91e63); box-shadow: 0 4px 0 #7f0000; }
        .btn-v:active { box-shadow: 0 0 0 #7f0000; transform: translateY(4px); }
        
        .btn-s { background: linear-gradient(135deg, #4a148c, #9c27b0); box-shadow: 0 4px 0 #311b92; }
        .btn-s:active { box-shadow: 0 0 0 #311b92; transform: translateY(4px); }
        
        .btn-safe { background: linear-gradient(135deg, #0d47a1, #2196f3); box-shadow: 0 4px 0 #01579b; }
        .btn-safe:active { box-shadow: 0 0 0 #01579b; transform: translateY(4px); }

    </style>
</head>
<body>

<div id="header">
    <div>
        <h1>SIA Model <span style="font-size:0.8em; border:1px solid red; padding:2px; border-radius:4px;">PATHOLOGICAL</span></h1>
        <span class="subtitle">Trauma Latching Simulator</span>
    </div>
    <div class="status-panel">
        <div id="action-display">EXPLORE</div>
        <div id="budget-val" style="font-size: 0.8rem; color:#888;">Budget: 100%</div>
    </div>
</div>

<div id="canvas-container">
    <div class="overlay-label" style="top: 10px; color: #ff4081;">■ Stimulus (V + 0.3*S)</div>
    <div class="overlay-label" style="top: 30px; color: #ffffff;">■ Trace (Memory/Trauma)</div>
    <div class="overlay-label" style="top: 50px; color: #00e676;">■ Budget (Mental Resource)</div>
    <canvas id="scope"></canvas>
</div>

<div id="controls">
    <button class="btn-v" id="btn-v">V<small>Violation</small></button>
    <button class="btn-s" id="btn-s">S<small>Surprise</small></button>
    <button class="btn-safe" id="btn-safe">SAFE BASE<small>Hold to Heal</small></button>
</div>

<script>
/**
 * SIA Logic: Pathological Edition
 * - Deep memories (trauma) never fade naturally.
 * - Recovery is only possible via Safe Context intervention.
 */

class RelayBank {
    constructor(N) {
        this.N = N;
        this.c = []; 
        this.q = []; 
        this.alpha = [];
        this.beta = [];

        for(let i=0; i<N; i++) {
            this.c[i] = (i + 0.5) / N;
            this.q[i] = 0;
            
            // --- 病的仕様への変更点 ---
            let width;
            if (this.c[i] < 0.3) {
                width = 0.05; // 浅い記憶はすぐ消える
            } else if (this.c[i] < 0.6) {
                width = 0.25; // 中程度の記憶
            } else {
                width = 1.0;  // 深い記憶は幅を無限大にする
            }
            
            this.alpha[i] = Math.min(this.c[i] + 0.1, 1.0); // 刻印はされやすい(0.1)
            
            // 【重要】深い領域では Beta をマイナスにする
            // これにより Stimulus が 0.0 になっても Beta を下回らないため、
            // 自然には絶対に OFF にならない（固着）。
            if (this.c[i] >= 0.6) {
                this.beta[i] = -1.0; 
            } else {
                this.beta[i] = Math.max(this.c[i] - width, 0.0);
            }
        }
    }

    // 引数を変更: (刺激, 安全基地フラグ)
    update(s, is_safe) {
        for(let i=0; i<this.N; i++) {
            
            // 1. 治療ロジック (Therapy)
            // 安全基地があり、かつ刺激が落ち着いている(0.2以下)なら強制解除
            if (is_safe && s < 0.2) {
                this.q[i] = 0; 
            }
            
            // 2. 通常の忘却ロジック (Natural Decay)
            // 深いトラウマの場合、betaが-1.0なので、ここは永遠にFalseになる
            else if (s <= this.beta[i]) {
                this.q[i] = 0; 
            } 
            
            // 3. 新規刻印 (Imprinting)
            // 安全基地でない場合のみ、新しい傷が増える
            else if (!is_safe && s >= this.alpha[i]) {
                this.q[i] = 1; 
            }
        }
    }

    readout(p=2.0) {
        let num = 0.0;
        let den = 0.0;
        for(let i=0; i<this.N; i++) {
            let w = Math.pow(this.c[i], p);
            num += w * this.q[i];
            den += w;
        }
        return num / (den + 1e-12);
    }
}

// --- Simulation State ---
const N = 64;
const bank = new RelayBank(N);
let input_V = 0.0;
let input_S = 0.0;
let is_safe = false;

// History buffers
const historyLen = 300;
const hist_V = new Array(historyLen).fill(0);
const hist_Trace = new Array(historyLen).fill(0);
const hist_Budget = new Array(historyLen).fill(0);

const RISK = { explore: 0.60, assert: 0.45, repair: 0.20, boundary: 0.10 };

function getAction(budget) {
    if (budget > RISK.explore) return { text: "EXPLORE (Active)", color: "#66bb6a" }; 
    if (budget > RISK.assert)  return { text: "ASSERT (Firm)",    color: "#42a5f5" }; 
    if (budget > RISK.repair)  return { text: "REPAIR (Hesitant)",color: "#ffa726" }; 
    return { text: "BOUNDARY (Closed)",color: "#ff5252" }; // Red
}

// --- Main Loop ---
function updatePhysics() {
    input_V *= 0.96; // 少しゆっくり減衰
    input_S *= 0.92;

    let stimulus = Math.min(input_V + 0.3 * input_S, 1.0);

    // 更新ロジックに is_safe を直接渡す
    bank.update(stimulus, is_safe);

    let trace = bank.readout(2.0);
    let budget = Math.max(0.8 - 0.7 * trace, 0.0);

    hist_V.shift(); hist_V.push(stimulus);
    hist_Trace.shift(); hist_Trace.push(trace);
    hist_Budget.shift(); hist_Budget.push(budget);

    const action = getAction(budget);
    const actionDisplay = document.getElementById('action-display');
    const budgetDisplay = document.getElementById('budget-val');
    
    actionDisplay.innerText = action.text;
    actionDisplay.style.color = action.color;
    budgetDisplay.innerText = `Budget: ${(budget*100).toFixed(0)}%`;
}

// --- Rendering ---
const canvas = document.getElementById('scope');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
    // コンテナのサイズに合わせる
    const container = document.getElementById('canvas-container');
    canvas.width = container.clientWidth;
    canvas.height = container.clientHeight;
}
window.addEventListener('resize', resizeCanvas);
// 初期化時にも呼ぶ（少し遅延させると安全）
setTimeout(resizeCanvas, 100);

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // Safe Context Visualization
    if (is_safe) {
        // 青みがかった背景
        let grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grd.addColorStop(0, "#0d1b2a");
        grd.addColorStop(1, "#1b263b");
        ctx.fillStyle = grd;
        ctx.fillRect(0,0, canvas.width, canvas.height);
        
        ctx.font = "bold 24px Courier New";
        ctx.fillStyle = "rgba(66, 165, 245, 0.2)";
        ctx.textAlign = "center";
        ctx.fillText("SAFE CONTEXT ACTIVE", canvas.width/2, canvas.height/2);
        ctx.font = "14px Courier New";
        ctx.fillText("(Healing Protocol Enabled)", canvas.width/2, canvas.height/2 + 25);
    }

    // Grid
    ctx.strokeStyle = "#333";
    ctx.lineWidth = 1;
    ctx.beginPath();
    for(let y=0.2; y<1.0; y+=0.2) {
        let Y = canvas.height * (1-y);
        ctx.moveTo(0, Y); ctx.lineTo(canvas.width, Y);
    }
    ctx.stroke();

    function drawLine(data, color, width) {
        ctx.beginPath();
        ctx.strokeStyle = color;
        ctx.lineWidth = width;
        let step = canvas.width / (historyLen - 1);
        for (let i = 0; i < historyLen; i++) {
            let x = i * step;
            let y = canvas.height * (1 - data[i] * 0.9 - 0.05);
            if (i===0) ctx.moveTo(x, y);
            else ctx.lineTo(x, y);
        }
        ctx.stroke();
    }

    drawLine(hist_V, "#ff4081", 2);      // Stimulus
    drawLine(hist_Budget, "#00e676", 1); // Budget
    drawLine(hist_Trace, is_safe ? "#90caf9" : "#ffffff", 3); // Trace

    requestAnimationFrame(draw);
}

setInterval(updatePhysics, 50);
requestAnimationFrame(draw);

// --- Input Handling ---
const btnV = document.getElementById('btn-v');
const btnS = document.getElementById('btn-s');
const btnSafe = document.getElementById('btn-safe');

// タッチ＆マウス対応（イベントの重複発火を防ぐ）
const addPress = (el, actionStart, actionEnd) => {
    // Mouse
    el.addEventListener('mousedown', (e) => { actionStart(); });
    el.addEventListener('mouseup',   (e) => { actionEnd(); });
    el.addEventListener('mouseleave',(e) => { actionEnd(); });
    
    // Touch
    el.addEventListener('touchstart', (e) => { 
        e.preventDefault(); // ダブルタップズーム等を防ぐ
        actionStart(); 
    }, {passive: false});
    
    el.addEventListener('touchend', (e) => { 
        e.preventDefault(); 
        actionEnd(); 
    }, {passive: false});
};

addPress(btnV, () => { input_V = Math.min(input_V + 0.3, 1.0); }, () => {});
addPress(btnS, () => { input_S = Math.min(input_S + 0.3, 1.0); }, () => {});
addPress(btnSafe, () => { is_safe = true; }, () => { is_safe = false; });

// Keyboard
document.addEventListener('keydown', (e) => {
    if (e.repeat) return;
    if (e.key.toLowerCase() === 'v') input_V = Math.min(input_V + 0.3, 1.0);
    if (e.key.toLowerCase() === 's') input_S = Math.min(input_S + 0.3, 1.0);
    if (e.key === ' ') is_safe = true;
});

document.addEventListener('keyup', (e) => {
    if (e.key === ' ') is_safe = false;
});

</script>
</body>
</html>
